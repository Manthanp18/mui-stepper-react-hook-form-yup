{"ast":null,"code":"import { appendErrors as e } from \"react-hook-form\";\nimport { toNestError as r, validateFieldsNatively as t } from \"@hookform/resolvers\";\n\nvar n = function n(_n, o, a) {\n  return void 0 === o && (o = {\n    abortEarly: !1\n  }), void 0 === a && (a = {}), function (i, s, u) {\n    try {\n      var c = function c() {\n        return l.error ? {\n          values: {},\n          errors: r((n = l.error, o = !u.shouldUseNativeValidation && \"all\" === u.criteriaMode, n.details.length ? n.details.reduce(function (r, t) {\n            var n = t.path.join(\".\");\n\n            if (r[n] || (r[n] = {\n              message: t.message,\n              type: t.type\n            }), o) {\n              var a = r[n].types,\n                  i = a && a[t.type];\n              r[n] = e(n, o, r, t.type, i ? [].concat(i, t.message) : t.message);\n            }\n\n            return r;\n          }, {}) : {}), u)\n        } : (u.shouldUseNativeValidation && t({}, u), {\n          errors: {},\n          values: l.value\n        });\n        var n, o;\n      },\n          v = Object.assign({}, o, {\n        context: s\n      }),\n          l = {},\n          f = function () {\n        if (\"sync\" === a.mode) l = _n.validate(i, v);else {\n          var e = function (e, r) {\n            try {\n              var t = e();\n            } catch (e) {\n              return r(e);\n            }\n\n            return t && t.then ? t.then(void 0, r) : t;\n          }(function () {\n            return Promise.resolve(_n.validateAsync(i, v)).then(function (e) {\n              l.value = e;\n            });\n          }, function (e) {\n            l.error = e;\n          });\n\n          if (e && e.then) return e.then(function () {});\n        }\n      }();\n\n      return Promise.resolve(f && f.then ? f.then(c) : c());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\n\nexport { n as joiResolver };","map":{"version":3,"mappings":";;;AAKA,IA+BaA,IACX,WACEC,EADF,EAEEC,CAFF,EAKEC,CALF,EAKEA;EAAAA,kBAHAD,CAGAC,KAHAD,IAAgB;IACdE,aAAY;EADE,CAGhBD,GAFc,WAEdA,CAFc,KAEdA,IAAkB,EAFJ,CAEdA,EAAkB,UAEbE,CAFa,EAELC,CAFK,EAEIC,CAFJ,EAEIA;IAAAA;MAAAA;QAgBtB,OAAIC,EAAOC,KAAPD,GACK;UACLH,QAAQ,EADH;UAELK,QAAQC,GAzDdF,IA2DUD,EAAOC,KA3DjBA,EACAG,KA2DWL,EAAQM,yBA3DnBD,IA4DqC,UAAzBL,EAAQO,YA7DpBL,EAGAA,EAAMM,OAANN,CAAcO,MAAdP,GACIA,EAAMM,OAANN,CAAcQ,MAAdR,CAAiD,UAACS,CAAD,EAAWT,CAAX,EAAWA;YAC1D,IAAMU,IAAQV,EAAMW,IAANX,CAAWY,IAAXZ,CAAgB,GAAhBA,CAAd;;YAMA,IAJKS,EAASC,CAATD,MACHA,EAASC,CAATD,IAAkB;cAAEI,SAASb,EAAMa,OAAjB;cAA0BC,MAAMd,EAAMc;YAAtC,CADfL,GAIDN,CAAJ,EAA8B;cAC5B,IAAMY,IAAQN,EAASC,CAATD,EAAgBM,KAA9B;cAAA,IACMC,IAAWD,KAASA,EAAMf,EAAMc,IAAZC,CAD1B;cAGAN,EAASC,CAATD,IAAkBQ,EAChBP,CADgBO,EAEhBd,CAFgBc,EAGhBR,CAHgBQ,EAIhBjB,EAAMc,IAJUG,EAKhBD,IACK,GAAgBE,MAAhB,CAAuBF,CAAvB,EAA6ChB,EAAMa,OAAnD,CADLG,GAEIhB,EAAMa,OAPMI,CAAlBR;YAWF;;YAAA,OAAOA,CAAP;UAAOA,CAtBTT,EAuBG,EAvBHA,CADJA,GAyBI,EA6BUE,GAMNJ,CANMI;QAFH,CADLH,IAcJD,EAAQM,yBAARN,IAAqCqB,EAAuB,EAAvBA,EAA2BrB,CAA3BqB,CAArCrB,EAEO;UACLG,QAAQ,EADH;UAELL,QAAQG,EAAOqB;QAFV,CAhBHrB,CAAJ;QAvDqB,IACvBC,CADuB,EAEvBG,CAFuB;MAEvBA,CAqCwBL;MAAAA,IAChBuB,IAAiBC,OAAOC,MAAPD,CAAc,EAAdA,EAAkB7B,CAAlB6B,EAAiC;QACtDzB;MADsD,CAAjCyB,CADDxB;MAAAA,IAKlBC,IAA8B,EALZD;MAAAA,IAKY0B;QAAA,IACL,WAAzB9B,EAAgB+B,IADc,EAEhC1B,IAASP,GAAOkC,QAAPlC,CAAgBI,CAAhBJ,EAAwB6B,CAAxB7B,CAATO,CAFgC,KAECsB;UAAAA;YAAAA;cAAAA;YAAAA;cAAAA;YAAAA;;YAAAA;UAAAA;YAAAA,uBAGV7B,GAAOmC,aAAPnC,CAAqBI,CAArBJ,EAA6B6B,CAA7B7B,CAHU6B,EAGmBA,IAHnBA,CAGmBA;cAAlDtB,EAAOqB,KAAPrB,GAAOqB,CAAPrB;YAAOqB,CAHwBC;UAGxBD,CAHwBC,EAGxBD,UACAQ,CADAR,EACAQ;YACP7B,EAAOC,KAAPD,GAAe6B,CAAf7B;UAAe6B,CALgBP;;UAKhBO;QAAAA;MAAAA,CAPe,EALZ9B;;MAYH8B;IAnBrB,CAOwB9B,CAPxB;MAAA;IAAA;EAAA,CAKEJ;AALF,CAhCF;;AAgCE","names":["joiResolver","schema","schemaOptions","resolverOptions","abortEarly","values","context","options","result","error","errors","toNestError","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","details","length","reduce","previous","_path","path","join","message","type","types","messages","appendErrors","concat","validateFieldsNatively","value","_schemaOptions","Object","assign","f","mode","validate","validateAsync","e"],"sources":["/Users/upforcetech/Desktop/9fkxo/node_modules/@hookform/resolvers/joi/src/joi.ts"],"sourcesContent":["import { appendErrors, FieldError } from 'react-hook-form';\nimport { toNestError, validateFieldsNatively } from '@hookform/resolvers';\nimport type { ValidationError } from 'joi';\nimport { Resolver } from './types';\n\nconst parseErrorSchema = (\n  error: ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  error.details.length\n    ? error.details.reduce<Record<string, FieldError>>((previous, error) => {\n        const _path = error.path.join('.');\n\n        if (!previous[_path]) {\n          previous[_path] = { message: error.message, type: error.type };\n        }\n\n        if (validateAllFieldCriteria) {\n          const types = previous[_path].types;\n          const messages = types && types[error.type!];\n\n          previous[_path] = appendErrors(\n            _path,\n            validateAllFieldCriteria,\n            previous,\n            error.type,\n            messages\n              ? ([] as string[]).concat(messages as string[], error.message)\n              : error.message,\n          ) as FieldError;\n        }\n\n        return previous;\n      }, {})\n    : {};\n\nexport const joiResolver: Resolver =\n  (\n    schema,\n    schemaOptions = {\n      abortEarly: false,\n    },\n    resolverOptions = {},\n  ) =>\n  async (values, context, options) => {\n    const _schemaOptions = Object.assign({}, schemaOptions, {\n      context,\n    });\n\n    let result: Record<string, any> = {};\n    if (resolverOptions.mode === 'sync') {\n      result = schema.validate(values, _schemaOptions);\n    } else {\n      try {\n        result.value = await schema.validateAsync(values, _schemaOptions);\n      } catch (e) {\n        result.error = e;\n      }\n    }\n\n    if (result.error) {\n      return {\n        values: {},\n        errors: toNestError(\n          parseErrorSchema(\n            result.error,\n            !options.shouldUseNativeValidation &&\n              options.criteriaMode === 'all',\n          ),\n          options,\n        ),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      errors: {},\n      values: result.value,\n    };\n  };\n"]},"metadata":{},"sourceType":"module"}